//--------------------------------------------------------------------
//		Timescale
//		Means that if you do #1 in the initial block of your
//		testbench, time is advanced by 1ns instead of 1ps
//--------------------------------------------------------------------
`timescale 1ns / 1ps

//--------------------------------------------------------------------
//		Design assignment #2, problem #1 sample testbench.
//--------------------------------------------------------------------
module dassign2_1_tb();

//----------------------------------------------------------------
//		Signal Declarations
//----------------------------------------------------------------

// clock
wire clk;

// inputs to multiplier
reg [7:0]   a, b;
reg         reset;

// outputs generated by multiplier
wire[15:0]  prod;
wire ready;

// variables for testing
integer     i;
reg[15:0]   correct;
integer     mult_err;

//----------------------------------------------------------------
//		Instantiate modules 
//----------------------------------------------------------------
clock_gen   clock_gen(clk);
multiply    multiply (clk, a, b, reset, prod, ready);


//----------------------------------------------------------------
//		Test Stimulus
//----------------------------------------------------------------
initial begin
    // Export timing information
    $dumpfile("timing2_1.vcd");
    $dumpvars;

    // Number of errors detected
    mult_err = 0;

    for(i=8'b0; i<127; i=i+1) begin
        // Wait for rising edge of clock
        @(posedge clk);

        // set inputs to random values
        // then tell the multiplier to start
        a = $urandom;
        b = $urandom;
        reset = 1'b1;

        $display("@%0t : %d * %d == ", $time, a, b);
        correct = a*b;

        // Wait for next rising edge of clock
        // then clear inputs 
        @(posedge clk);
        a = 8'b0;
        b = 8'b0;
        reset = 1'b0;

        // Wait until multiplier indicates ready
        // then check output at next rising edge of clock
        @(posedge ready);
        @(posedge clk);
        if(prod !== correct) begin
            $display("@%0t :   %d (should be %d)", $time, prod, correct);
            mult_err=mult_err+1;
        end
    end

    if(!mult_err)
        $display("ASSERTION PASSED CHECK mult");
    else
        $display("ASSERTION FAILED CHECK mult WITH ERRNO %d\n",mult_err);

    $finish;
end
endmodule
